import { NextRequest, NextResponse } from 'next/server';
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import { suppliers, purchaseOrders, products, inventorySnapshots } from '@/db/schema';
import { eq, desc, gte, and } from 'drizzle-orm';

const connectionString = process.env.DATABASE_URL || 'postgresql://postgres:password@localhost:5432/inventory_db';
const client = postgres(connectionString);
const db = drizzle(client);

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const supplierId = searchParams.get('supplierId');
    const status = searchParams.get('status');

    let response: any = {
      agent: 'Supplier Agent',
      status: 'online',
      lastUpdate: new Date().toISOString(),
      summary: {
        totalSuppliers: 0,
        activeOrders: 0,
        pendingOrders: 0,
        completedOrders: 0,
        totalSpent: 0
      },
      suppliers: [],
      orders: []
    };

    // Get suppliers
    const suppliersData = supplierId 
      ? await db.select().from(suppliers).where(eq(suppliers.id, supplierId))
      : await db.select().from(suppliers).orderBy(desc(suppliers.id));

    response.suppliers = suppliersData;

    // Get purchase orders
    let orderConditions = [];
    if (supplierId) orderConditions.push(eq(purchaseOrders.supplier_id, supplierId));
    if (status) orderConditions.push(eq(purchaseOrders.order_status, status));

    const ordersData = await db.select()
      .from(purchaseOrders)
      .where(orderConditions.length > 0 ? and(...orderConditions) : undefined)
      .orderBy(desc(purchaseOrders.ordered_at))
      .limit(100);

    response.orders = ordersData;

    // Calculate summary metrics
    response.summary.totalSuppliers = suppliersData.length;
    response.summary.activeOrders = ordersData.filter(order => order.order_status === 'pending' || order.order_status === 'shipped').length;
    response.summary.pendingOrders = ordersData.filter(order => order.order_status === 'pending').length;
    response.summary.completedOrders = ordersData.filter(order => order.order_status === 'received').length;

    // Calculate total spent (simplified)
    response.summary.totalSpent = ordersData
      .filter(order => order.order_status === 'received')
      .reduce((sum, order) => sum + (order.order_quantity * 50), 0); // Assuming average price of 50

    return NextResponse.json(response);
  } catch (error) {
    console.error('Supplier Agent API Error:', error);
    return NextResponse.json(
      { error: 'Failed to get supplier data', agent: 'Supplier Agent', status: 'error' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { productId, supplierId, orderQuantity, expectedDelivery, autoGenerated = true } = body;

    // Validate product exists
    const product = await db.select().from(products).where(eq(products.id, productId)).limit(1);
    if (product.length === 0) {
      return NextResponse.json({ error: 'Product not found' }, { status: 404 });
    }

    // Validate supplier exists
    const supplier = await db.select().from(suppliers).where(eq(suppliers.id, supplierId)).limit(1);
    if (supplier.length === 0) {
      return NextResponse.json({ error: 'Supplier not found' }, { status: 404 });
    }

    // Create new purchase order
    const order = await db.insert(purchaseOrders).values({
      product_id: productId,
      supplier_id: supplierId,
      order_quantity: orderQuantity,
      order_status: 'pending',
      ordered_at: new Date(),
      expected_delivery: expectedDelivery ? new Date(expectedDelivery) : new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      auto_generated: autoGenerated
    }).returning();

    return NextResponse.json({
      success: true,
      message: 'Purchase order created successfully',
      order: order[0]
    });
  } catch (error) {
    console.error('Purchase Order Creation Error:', error);
    return NextResponse.json(
      { error: 'Failed to create purchase order' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { action = 'auto_order' } = body;

    if (action === 'auto_order') {
      const autoOrders = await generateAutoOrders();
      
      return NextResponse.json({
        success: true,
        message: 'Auto-order generation completed',
        generatedOrders: autoOrders.length,
        orders: autoOrders
      });
    }

    if (action === 'update_status') {
      const { orderId, status } = body;
      
      const updatedOrder = await db.update(purchaseOrders)
        .set({ order_status: status })
        .where(eq(purchaseOrders.id, orderId))
        .returning();

      if (updatedOrder.length === 0) {
        return NextResponse.json({ error: 'Order not found' }, { status: 404 });
      }

      return NextResponse.json({
        success: true,
        message: 'Order status updated successfully',
        order: updatedOrder[0]
      });
    }

    return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
  } catch (error) {
    console.error('Supplier Agent Action Error:', error);
    return NextResponse.json(
      { error: 'Failed to perform supplier action' },
      { status: 500 }
    );
  }
}

async function generateAutoOrders() {
  const autoOrders = [];
  const now = new Date();

  // Get all products
  const allProducts = await db.select().from(products).limit(30);

  for (const product of allProducts) {
    // Get current inventory
    const currentInventory = await db.select().from(inventorySnapshots)
      .where(eq(inventorySnapshots.product_id, product.id))
      .orderBy(desc(inventorySnapshots.recorded_at))
      .limit(1);

    if (currentInventory.length > 0) {
      const currentStock = currentInventory[0].stock_level;
      const reorderPoint = getReorderPoint(product.name);
      const orderQuantity = getOrderQuantity(product.name);

      // Check if reorder is needed
      if (currentStock <= reorderPoint) {
        // Find suitable supplier
        const suitableSuppliers = await db.select().from(suppliers)
          .where(eq(suppliers.preferred_products, product.name))
          .limit(1);

        if (suitableSuppliers.length > 0) {
          // Check if order already exists
          const existingOrder = await db.select().from(purchaseOrders)
            .where(and(
              eq(purchaseOrders.product_id, product.id),
              eq(purchaseOrders.order_status, 'pending')
            ))
            .limit(1);

          if (existingOrder.length === 0) {
            const order = await db.insert(purchaseOrders).values({
              product_id: product.id,
              supplier_id: suitableSuppliers[0].id,
              order_quantity: orderQuantity,
              order_status: 'pending',
              ordered_at: new Date(),
              expected_delivery: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
              auto_generated: true
            }).returning();

            autoOrders.push(order[0]);
          }
        }
      }
    }
  }

  return autoOrders;
}

function getReorderPoint(productName: string): number {
  const reorderPoints: { [key: string]: number } = {
    'Milk': 30,
    'Bread': 25,
    'Eggs': 20,
    'Chicken': 15,
    'Fish': 10,
    'Rice': 20,
    'Dal': 18,
    'Onions': 25,
    'Tomatoes': 30,
    'Potatoes': 35,
    'Bananas': 40,
    'Apples': 20,
    'Mango': 15,
    'Watermelon': 10,
    'Cream': 12,
    'Butter': 15,
    'Oil': 8,
    'Sugar': 10,
    'Tea': 12,
    'Coke': 25,
    'Soda': 20,
    'Lassi': 15,
    'Biscuits': 30,
    'Chips': 35,
    'Samosa': 20,
    'Vada': 15,
    'Pav': 25,
    'Bread Roll': 20,
    'Coriander': 10,
    'Jeera': 5,
    'Turmeric': 8,
    'Chutney': 10,
    'Pickle': 8,
    'Tomato Puree': 8,
    'Peas': 15,
    'Carrot': 20,
    'Cucumber': 15,
    'Cabbage': 12,
    'Spinach': 10,
    'Green Tea': 8,
    'Ice Cream': 12,
    'Gulab Jamun': 8,
    'Rasgulla': 8,
    'Chikki': 10,
    'Farsan': 12,
    'Dates': 8
  };

  return reorderPoints[productName] || 20;
}

function getOrderQuantity(productName: string): number {
  const orderQuantities: { [key: string]: number } = {
    'Milk': 100,
    'Bread': 80,
    'Eggs': 60,
    'Chicken': 50,
    'Fish': 40,
    'Rice': 100,
    'Dal': 80,
    'Onions': 120,
    'Tomatoes': 100,
    'Potatoes': 150,
    'Bananas': 200,
    'Apples': 80,
    'Mango': 60,
    'Watermelon': 40,
    'Cream': 50,
    'Butter': 60,
    'Oil': 30,
    'Sugar': 40,
    'Tea': 50,
    'Coke': 100,
    'Soda': 80,
    'Lassi': 60,
    'Biscuits': 120,
    'Chips': 150,
    'Samosa': 80,
    'Vada': 60,
    'Pav': 100,
    'Bread Roll': 80,
    'Coriander': 40,
    'Jeera': 20,
    'Turmeric': 30,
    'Chutney': 40,
    'Pickle': 30,
    'Tomato Puree': 30,
    'Peas': 60,
    'Carrot': 80,
    'Cucumber': 60,
    'Cabbage': 50,
    'Spinach': 40,
    'Green Tea': 30,
    'Ice Cream': 50,
    'Gulab Jamun': 30,
    'Rasgulla': 30,
    'Chikki': 40,
    'Farsan': 50,
    'Dates': 30
  };

  return orderQuantities[productName] || 50;
} 